{
  "version": 3,
  "sources": ["../../datatables.net-scroller-dt/js/scroller.dataTables.mjs", "../../datatables.net-scroller/js/dataTables.scroller.mjs"],
  "sourcesContent": ["/*! DataTables styling wrapper for Scroller\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport jQuery from 'jquery';\nimport DataTable from 'datatables.net-dt';\nimport Scroller from 'datatables.net-scroller';\n\n// Allow reassignment of the $ variable\nlet $ = jQuery;\n\n\n\nexport default DataTable;\n", "/*! Scroller 2.4.3\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport jQuery from 'jquery';\nimport DataTable from 'datatables.net';\n\n// Allow reassignment of the $ variable\nlet $ = jQuery;\n\n\n/**\n * @summary     Scroller\n * @description Virtual rendering for DataTables\n * @version     2.4.3\n * @copyright   SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/**\n * Scroller is a virtual rendering plug-in for DataTables which allows large\n * datasets to be drawn on screen very quickly. What the virtual rendering means\n * is that only the visible portion of the table (and a bit to either side to make\n * the scrolling smooth) is drawn, while the scrolling container gives the\n * visual impression that the whole table is visible. This is done by making use\n * of the pagination abilities of DataTables and moving the table around in the\n * scrolling container DataTables adds to the page. The scrolling container is\n * forced to the height it would be for the full table display using an extra\n * element.\n *\n * Note that rows in the table MUST all be the same height. Information in a cell\n * which expands on to multiple lines will cause some odd behaviour in the scrolling.\n *\n * Scroller is initialised by simply including the letter 'S' in the sDom for the\n * table you want to have this feature enabled on. Note that the 'S' must come\n * AFTER the 't' parameter in `dom`.\n *\n * Key features include:\n *   <ul class=\"limit_length\">\n *     <li>Speed! The aim of Scroller for DataTables is to make rendering large data sets fast</li>\n *     <li>Full compatibility with deferred rendering in DataTables for maximum speed</li>\n *     <li>Display millions of rows</li>\n *     <li>Integration with state saving in DataTables (scrolling position is saved)</li>\n *     <li>Easy to use</li>\n *   </ul>\n *\n *  @class\n *  @constructor\n *  @global\n *  @param {object} dt DataTables settings object or API instance\n *  @param {object} [opts={}] Configuration object for Scroller. Options\n *    are defined by {@link Scroller.defaults}\n *\n *  @requires jQuery 1.7+\n *  @requires DataTables 1.11.0+\n */\nvar Scroller = function (dt, opts) {\n\t/* Sanity check - you just know it will happen */\n\tif (!(this instanceof Scroller)) {\n\t\talert(\n\t\t\t\"Scroller warning: Scroller must be initialised with the 'new' keyword.\"\n\t\t);\n\t\treturn;\n\t}\n\n\tif (opts === undefined) {\n\t\topts = {};\n\t}\n\n\tvar dtApi = $.fn.dataTable.Api(dt);\n\n\t/**\n\t * Settings object which contains customisable information for the Scroller instance\n\t * @namespace\n\t * @private\n\t * @extends Scroller.defaults\n\t */\n\tthis.s = {\n\t\t/**\n\t\t * DataTables settings object\n\t\t *  @type     object\n\t\t *  @default  Passed in as first parameter to constructor\n\t\t */\n\t\tdt: dtApi.settings()[0],\n\n\t\t/**\n\t\t * DataTables API instance\n\t\t *  @type     DataTable.Api\n\t\t */\n\t\tdtApi: dtApi,\n\n\t\t/**\n\t\t * Pixel location of the top of the drawn table in the viewport\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\ttableTop: 0,\n\n\t\t/**\n\t\t * Pixel location of the bottom of the drawn table in the viewport\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\ttableBottom: 0,\n\n\t\t/**\n\t\t * Pixel location of the boundary for when the next data set should be loaded and drawn\n\t\t * when scrolling up the way.\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t *  @private\n\t\t */\n\t\tredrawTop: 0,\n\n\t\t/**\n\t\t * Pixel location of the boundary for when the next data set should be loaded and drawn\n\t\t * when scrolling down the way. Note that this is actually calculated as the offset from\n\t\t * the top.\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t *  @private\n\t\t */\n\t\tredrawBottom: 0,\n\n\t\t/**\n\t\t * Auto row height or not indicator\n\t\t *  @type     bool\n\t\t *  @default  0\n\t\t */\n\t\tautoHeight: true,\n\n\t\t/**\n\t\t * Number of rows calculated as visible in the visible viewport\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\tviewportRows: 0,\n\n\t\t/**\n\t\t * setTimeout reference for state saving, used when state saving is enabled in the DataTable\n\t\t * and when the user scrolls the viewport in order to stop the cookie set taking too much\n\t\t * CPU!\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\tstateTO: null,\n\n\t\tstateSaveThrottle: function () {},\n\n\t\t/**\n\t\t * setTimeout reference for the redraw, used when server-side processing is enabled in the\n\t\t * DataTables in order to prevent DoSing the server\n\t\t *  @type     int\n\t\t *  @default  null\n\t\t */\n\t\tdrawTO: null,\n\n\t\theights: {\n\t\t\tjump: null,\n\t\t\tpage: null,\n\t\t\tvirtual: null,\n\t\t\tscroll: null,\n\n\t\t\t/**\n\t\t\t * Height of rows in the table\n\t\t\t *  @type     int\n\t\t\t *  @default  0\n\t\t\t */\n\t\t\trow: null,\n\n\t\t\t/**\n\t\t\t * Pixel height of the viewport\n\t\t\t *  @type     int\n\t\t\t *  @default  0\n\t\t\t */\n\t\t\tviewport: null,\n\t\t\tlabelHeight: 0,\n\t\t\txbar: 0\n\t\t},\n\n\t\ttopRowFloat: 0,\n\t\tscrollDrawDiff: null,\n\t\tloaderVisible: false,\n\t\tforceReposition: false,\n\t\tbaseRowTop: 0,\n\t\tbaseScrollTop: 0,\n\t\tmousedown: false,\n\t\tlastScrollTop: 0\n\t};\n\n\t// @todo The defaults should extend a `c` property and the internal settings\n\t// only held in the `s` property. At the moment they are mixed\n\tthis.s = $.extend(this.s, Scroller.oDefaults, opts);\n\n\t// Workaround for row height being read from height object (see above comment)\n\tthis.s.heights.row = this.s.rowHeight;\n\n\t/**\n\t * DOM elements used by the class instance\n\t * @private\n\t * @namespace\n\t *\n\t */\n\tthis.dom = {\n\t\tforce: document.createElement('div'),\n\t\tlabel: $('<div class=\"dts_label\">0</div>'),\n\t\tscroller: null,\n\t\ttable: null,\n\t\tloader: null\n\t};\n\n\t// Attach the instance to the DataTables instance so it can be accessed in\n\t// future. Don't initialise Scroller twice on the same table\n\tif (this.s.dt.oScroller) {\n\t\treturn;\n\t}\n\n\tthis.s.dt.oScroller = this;\n\n\t/* Let's do it */\n\tthis.construct();\n};\n\n$.extend(Scroller.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods - to be exposed via the DataTables API\n\t */\n\n\t/**\n\t * Calculate and store information about how many rows are to be displayed\n\t * in the scrolling viewport, based on current dimensions in the browser's\n\t * rendering. This can be particularly useful if the table is initially\n\t * drawn in a hidden element - for example in a tab.\n\t *  @param {bool} [redraw=true] Redraw the table automatically after the recalculation, with\n\t *    the new dimensions forming the basis for the draw.\n\t *  @returns {void}\n\t */\n\tmeasure: function (redraw) {\n\t\tif (this.s.autoHeight) {\n\t\t\tthis._calcRowHeight();\n\t\t}\n\n\t\tvar heights = this.s.heights;\n\n\t\tif (heights.row) {\n\t\t\theights.viewport = this._parseHeight(\n\t\t\t\t$(this.dom.scroller).css('max-height')\n\t\t\t);\n\n\t\t\tthis.s.viewportRows =\n\t\t\t\tparseInt(heights.viewport / heights.row, 10) + 1;\n\t\t\tthis.s.dt._iDisplayLength =\n\t\t\t\tthis.s.viewportRows * this.s.displayBuffer;\n\t\t}\n\n\t\tvar label = this.dom.label.outerHeight();\n\n\t\theights.xbar =\n\t\t\tthis.dom.scroller.offsetHeight - this.dom.scroller.clientHeight;\n\t\theights.labelHeight = label;\n\n\t\tif (redraw === undefined || redraw) {\n\t\t\tthis.s.dtApi.draw(false);\n\t\t}\n\t},\n\n\t/**\n\t * Get information about current displayed record range. This corresponds to\n\t * the information usually displayed in the \"Info\" block of the table.\n\t *\n\t * @returns {object} info as an object:\n\t *  {\n\t *      start: {int}, // the 0-indexed record at the top of the viewport\n\t *      end:   {int}, // the 0-indexed record at the bottom of the viewport\n\t *  }\n\t */\n\tpageInfo: function () {\n\t\tvar dt = this.s.dt,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiTotal = dt.fnRecordsDisplay(),\n\t\t\tiPossibleEnd = Math.ceil(\n\t\t\t\tthis.pixelsToRow(\n\t\t\t\t\tiScrollTop + this.s.heights.viewport,\n\t\t\t\t\tfalse,\n\t\t\t\t\tthis.s.ani\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn {\n\t\t\tstart: Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani)),\n\t\t\tend: iTotal < iPossibleEnd ? iTotal - 1 : iPossibleEnd - 1\n\t\t};\n\t},\n\n\t/**\n\t * Calculate the row number that will be found at the given pixel position\n\t * (y-scroll).\n\t *\n\t * Please note that when the height of the full table exceeds 1 million\n\t * pixels, Scroller switches into a non-linear mode for the scrollbar to fit\n\t * all of the records into a finite area, but this function returns a linear\n\t * value (relative to the last non-linear positioning).\n\t *  @param {int} pixels Offset from top to calculate the row number of\n\t *  @param {int} [intParse=true] If an integer value should be returned\n\t *  @param {int} [virtual=false] Perform the calculations in the virtual domain\n\t *  @returns {int} Row index\n\t */\n\tpixelsToRow: function (pixels, intParse, virtual) {\n\t\tvar diff = pixels - this.s.baseScrollTop;\n\t\tvar row = virtual\n\t\t\t? (this._domain('physicalToVirtual', this.s.baseScrollTop) + diff) /\n\t\t\t\tthis.s.heights.row\n\t\t\t: diff / this.s.heights.row + this.s.baseRowTop;\n\n\t\treturn intParse || intParse === undefined ? parseInt(row, 10) : row;\n\t},\n\n\t/**\n\t * Calculate the pixel position from the top of the scrolling container for\n\t * a given row\n\t *  @param {int} iRow Row number to calculate the position of\n\t *  @returns {int} Pixels\n\t */\n\trowToPixels: function (rowIdx, intParse, virtual) {\n\t\tvar pixels;\n\t\tvar diff = rowIdx - this.s.baseRowTop;\n\n\t\tif (virtual) {\n\t\t\tpixels = this._domain('virtualToPhysical', this.s.baseScrollTop);\n\t\t\tpixels += diff * this.s.heights.row;\n\t\t}\n\t\telse {\n\t\t\tpixels = this.s.baseScrollTop;\n\t\t\tpixels += diff * this.s.heights.row;\n\t\t}\n\n\t\treturn intParse || intParse === undefined\n\t\t\t? parseInt(pixels, 10)\n\t\t\t: pixels;\n\t},\n\n\t/**\n\t * Calculate the row number that will be found at the given pixel position (y-scroll)\n\t *  @param {int} row Row index to scroll to\n\t *  @param {bool} [animate=true] Animate the transition or not\n\t *  @returns {void}\n\t */\n\tscrollToRow: function (row, animate) {\n\t\tvar that = this;\n\t\tvar ani = false;\n\t\tvar px = this.rowToPixels(row);\n\n\t\t// We need to know if the table will redraw or not before doing the\n\t\t// scroll. If it will not redraw, then we need to use the currently\n\t\t// displayed table, and scroll with the physical pixels. Otherwise, we\n\t\t// need to calculate the table's new position from the virtual\n\t\t// transform.\n\t\tvar preRows = ((this.s.displayBuffer - 1) / 2) * this.s.viewportRows;\n\t\tvar drawRow = row - preRows;\n\t\tif (drawRow < 0) {\n\t\t\tdrawRow = 0;\n\t\t}\n\n\t\tif (\n\t\t\t(px > this.s.redrawBottom || px < this.s.redrawTop) &&\n\t\t\tthis.s.dt._iDisplayStart !== drawRow\n\t\t) {\n\t\t\tani = true;\n\t\t\tpx = this._domain('virtualToPhysical', row * this.s.heights.row);\n\n\t\t\t// If we need records outside the current draw region, but the new\n\t\t\t// scrolling position is inside that (due to the non-linear nature\n\t\t\t// for larger numbers of records), we need to force position update.\n\t\t\tif (this.s.redrawTop < px && px < this.s.redrawBottom) {\n\t\t\t\tthis.s.forceReposition = true;\n\t\t\t\tanimate = false;\n\t\t\t}\n\t\t}\n\n\t\tif (animate === undefined || animate) {\n\t\t\tthis.s.ani = ani;\n\t\t\t$(this.dom.scroller).animate(\n\t\t\t\t{\n\t\t\t\t\tscrollTop: px\n\t\t\t\t},\n\t\t\t\tfunction () {\n\t\t\t\t\t// This needs to happen after the animation has completed and\n\t\t\t\t\t// the final scroll event fired\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tthat.s.ani = false;\n\t\t\t\t\t}, 250);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\t$(this.dom.scroller).scrollTop(px);\n\t\t}\n\t},\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Initialisation for Scroller\n\t *  @returns {void}\n\t *  @private\n\t */\n\tconstruct: function () {\n\t\tvar that = this;\n\t\tvar dt = this.s.dtApi;\n\n\t\t/* Sanity check */\n\t\tif (!this.s.dt.oFeatures.bPaginate) {\n\t\t\tthrow new Error(\n\t\t\t\t'Pagination must be enabled for Scroller to operate'\n\t\t\t);\n\t\t}\n\n\t\t/* Insert a div element that we can use to force the DT scrolling container to\n\t\t * the height that would be required if the whole table was being displayed\n\t\t */\n\t\tthis.dom.force.style.position = 'relative';\n\t\tthis.dom.force.style.top = '0px';\n\t\tthis.dom.force.style.left = '0px';\n\t\tthis.dom.force.style.width = '1px';\n\n\t\tthis.dom.scroller = dt.table().node().parentNode;\n\t\tthis.dom.scroller.appendChild(this.dom.force);\n\t\tthis.dom.scroller.style.position = 'relative';\n\n\t\tthis.dom.table = $('>table', this.dom.scroller)[0];\n\t\tthis.dom.table.style.position = 'absolute';\n\t\tthis.dom.table.style.top = '0px';\n\t\tthis.dom.table.style.left = '0px';\n\n\t\t// Add class to 'announce' that we are a Scroller table\n\t\t$(dt.table().container()).addClass('dts DTS');\n\n\t\tthis.dom.label.appendTo(this.dom.scroller);\n\n\t\t/* Initial size calculations */\n\t\tif (this.s.heights.row && this.s.heights.row != 'auto') {\n\t\t\tthis.s.autoHeight = false;\n\t\t}\n\n\t\t// Scrolling callback to see if a page change is needed\n\t\tthis.s.ingnoreScroll = true;\n\t\t$(this.dom.scroller).on('scroll.dt-scroller', function (e) {\n\t\t\tthat._scroll.call(that);\n\t\t});\n\n\t\t// In iOS we catch the touchstart event in case the user tries to scroll\n\t\t// while the display is already scrolling\n\t\t$(this.dom.scroller).on('touchstart.dt-scroller', function () {\n\t\t\tthat._scroll.call(that);\n\t\t});\n\n\t\t$(this.dom.scroller)\n\t\t\t.on('mousedown.dt-scroller', function () {\n\t\t\t\tthat.s.mousedown = true;\n\t\t\t})\n\t\t\t.on('mouseup.dt-scroller', function () {\n\t\t\t\tthat.s.labelVisible = false;\n\t\t\t\tthat.s.mousedown = false;\n\t\t\t\tthat.dom.label.css('display', 'none');\n\t\t\t});\n\n\t\t// On resize, update the information element, since the number of rows shown might change\n\t\t$(window).on('resize.dt-scroller', function () {\n\t\t\tthat.measure(false);\n\t\t\tthat._info();\n\t\t});\n\n\t\t// Add a state saving parameter to the DT state saving so we can restore the exact\n\t\t// position of the scrolling.\n\t\tvar initialStateSave = true;\n\t\tvar loadedState = dt.state.loaded();\n\n\t\tdt.on('stateSaveParams.scroller', function (e, settings, data) {\n\t\t\tif (initialStateSave && loadedState) {\n\t\t\t\tdata.scroller = loadedState.scroller;\n\t\t\t\tinitialStateSave = false;\n\n\t\t\t\tif (data.scroller) {\n\t\t\t\t\tthat.s.lastScrollTop = data.scroller.scrollTop;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Need to used the saved position on init\n\t\t\t\tdata.scroller = {\n\t\t\t\t\ttopRow: that.s.topRowFloat,\n\t\t\t\t\tbaseRowTop: that.s.baseRowTop\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tdt.on('stateLoadParams.scroller', function (e, settings, data) {\n\t\t\tif (data.scroller !== undefined) {\n\t\t\t\tthat.scrollToRow(data.scroller.topRow);\n\t\t\t}\n\t\t});\n\n\t\tthis.measure(false);\n\n\t\tif (loadedState && loadedState.scroller) {\n\t\t\tthis.s.topRowFloat = loadedState.scroller.topRow;\n\t\t\tthis.s.baseRowTop = loadedState.scroller.baseRowTop;\n\n\t\t\t// Reconstruct the scroll positions from the rows - it is possible the\n\t\t\t// row height has changed e.g. if the styling framework has changed.\n\t\t\t// The scroll top is used in `_draw` further down.\n\t\t\tthis.s.baseScrollTop = this.s.baseRowTop * this.s.heights.row;\t\t\t\n\t\t\tloadedState.scroller.scrollTop = this._domain('physicalToVirtual', this.s.topRowFloat * this.s.heights.row);\n\t\t}\n\n\t\tthat.s.stateSaveThrottle = DataTable.util.throttle(function () {\n\t\t\tthat.s.dtApi.state.save();\n\t\t}, 500);\n\n\t\tdt.on('init.scroller', function () {\n\t\t\tthat.measure(false);\n\n\t\t\t// Setting to `jump` will instruct _draw to calculate the scroll top\n\t\t\t// position\n\t\t\tthat.s.scrollType = 'jump';\n\t\t\tthat._draw();\n\n\t\t\t// Update the scroller when the DataTable is redrawn\n\t\t\tdt.on('draw.scroller', function () {\n\t\t\t\tthat._draw();\n\t\t\t});\n\t\t});\n\n\t\t// Set height before the draw happens, allowing everything else to update\n\t\t// on draw complete without worry for roder.\n\t\tdt.on('preDraw.dt.scroller', function () {\n\t\t\tthat._scrollForce();\n\t\t});\n\n\t\t// Destructor\n\t\tdt.on('destroy.scroller', function () {\n\t\t\t$(window).off('resize.dt-scroller');\n\t\t\t$(that.dom.scroller).off('.dt-scroller');\n\t\t\t$(that.s.dt.nTable).off('.scroller');\n\n\t\t\t$(that.s.dt.nTableWrapper).removeClass('DTS');\n\t\t\t$('div.DTS_Loading', that.dom.scroller.parentNode).remove();\n\n\t\t\tthat.dom.table.style.position = '';\n\t\t\tthat.dom.table.style.top = '';\n\t\t\tthat.dom.table.style.left = '';\n\t\t});\n\t},\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\t/**\n\t * Automatic calculation of table row height. This is just a little tricky here as using\n\t * initialisation DataTables has tale the table out of the document, so we need to create\n\t * a new table and insert it into the document, calculate the row height and then whip the\n\t * table out.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_calcRowHeight: function () {\n\t\tvar dt = this.s.dt;\n\t\tvar origTable = dt.nTable;\n\t\tvar nTable = origTable.cloneNode(false);\n\t\tvar tbody = $('<tbody/>').appendTo(nTable);\n\t\tvar dtClasses = dt.oClasses;\n\n\t\t// Different locations for classes in DT2\n\t\tvar classes = DataTable.versionCheck('2')\n\t\t\t? {\n\t\t\t\t\tcontainer: dtClasses.container,\n\t\t\t\t\tscroller: dtClasses.scrolling.container,\n\t\t\t\t\tbody: dtClasses.scrolling.body\n\t\t\t}\n\t\t\t: {\n\t\t\t\t\tcontainer: dtClasses.sWrapper,\n\t\t\t\t\tscroller: dtClasses.sScrollWrapper,\n\t\t\t\t\tbody: dtClasses.sScrollBody\n\t\t\t};\n\n\t\tvar container = $(\n\t\t\t'<div class=\"' +\n\t\t\t\tclasses.container +\n\t\t\t\t' DTS\"><div class=\"' +\n\t\t\t\tclasses.scroller +\n\t\t\t\t'\"><div class=\"' +\n\t\t\t\tclasses.body +\n\t\t\t\t'\"></div></div></div>'\n\t\t);\n\n\t\t// Want 3 rows in the sizing table so :first-child and :last-child\n\t\t// CSS styles don't come into play - take the size of the middle row\n\t\t$('tbody tr:lt(4)', origTable).clone().appendTo(tbody);\n\t\tvar rowsCount = $('tr', tbody).length;\n\n\t\tif (rowsCount === 1) {\n\t\t\ttbody.prepend('<tr><td>&#160;</td></tr>');\n\t\t\ttbody.append('<tr><td>&#160;</td></tr>');\n\t\t}\n\t\telse {\n\t\t\tfor (; rowsCount < 3; rowsCount++) {\n\t\t\t\ttbody.append('<tr><td>&#160;</td></tr>');\n\t\t\t}\n\t\t}\n\n\t\t$('div.' + classes.body, container).append(nTable);\n\n\t\t// If initialised using `dom`, use the holding element as the insert point\n\t\tvar insertEl = this.s.dt.nHolding || origTable.parentNode;\n\n\t\tif (!$(insertEl).is(':visible')) {\n\t\t\tinsertEl = 'body';\n\t\t}\n\n\t\t// Remove form element links as they might select over others (particularly radio and checkboxes)\n\t\tcontainer.find('input').removeAttr('name');\n\n\t\tcontainer.appendTo(insertEl);\n\t\tthis.s.heights.row = $('tr', tbody).eq(1).outerHeight();\n\n\t\tcontainer.remove();\n\t},\n\n\t/**\n\t * Draw callback function which is fired when the DataTable is redrawn. The main function of\n\t * this method is to position the drawn table correctly the scrolling container for the rows\n\t * that is displays as a result of the scrolling position.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_draw: function () {\n\t\tvar that = this,\n\t\t\theights = this.s.heights,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiTableHeight = $(this.s.dt.nTable).height(),\n\t\t\tdisplayStart = this.s.dt._iDisplayStart,\n\t\t\tdisplayLen = this.s.dt._iDisplayLength,\n\t\t\tdisplayEnd = this.s.dt.fnRecordsDisplay(),\n\t\t\tviewportEndY = iScrollTop + heights.viewport;\n\n\t\t// Disable the scroll event listener while we are updating the DOM\n\t\tthis.s.skip = true;\n\n\t\t// If paging is reset\n\t\tif (\n\t\t\t(this.s.dt.bSorted || this.s.dt.bFiltered) &&\n\t\t\tdisplayStart === 0 &&\n\t\t\t!this.s.dt._drawHold\n\t\t) {\n\t\t\tthis.s.topRowFloat = 0;\n\t\t}\n\n\t\tiScrollTop =\n\t\t\tthis.s.scrollType === 'jump'\n\t\t\t\t? this._domain(\n\t\t\t\t\t'virtualToPhysical',\n\t\t\t\t\tthis.s.topRowFloat * heights.row\n\t\t\t\t)\n\t\t\t\t: iScrollTop;\n\n\t\t// Store positional information so positional calculations can be based\n\t\t// upon the current table draw position\n\t\tthis.s.baseScrollTop = iScrollTop;\n\t\tthis.s.baseRowTop = this.s.topRowFloat;\n\n\t\t// Position the table in the virtual scroller\n\t\tvar tableTop =\n\t\t\tiScrollTop - (this.s.topRowFloat - displayStart) * heights.row;\n\t\tif (displayStart === 0) {\n\t\t\ttableTop = 0;\n\t\t}\n\t\telse if (displayStart + displayLen >= displayEnd) {\n\t\t\ttableTop = heights.scroll - iTableHeight;\n\t\t}\n\t\telse {\n\t\t\tvar iTableBottomY = tableTop + iTableHeight;\n\t\t\tif (iTableBottomY < viewportEndY) {\n\t\t\t\t// The last row of the data is above the end of the viewport.\n\t\t\t\t// This means the background is visible, which is not what the user expects.\n\t\t\t\tvar newTableTop = viewportEndY - iTableHeight;\n\t\t\t\tvar diffPx = newTableTop - tableTop;\n\t\t\t\tthis.s.baseScrollTop += diffPx + 1; // Update start row number in footer.\n\t\t\t\ttableTop = newTableTop; // Move table so last line of data is at the bottom of the viewport.\n\t\t\t}\n\t\t}\n\n\t\tthis.dom.table.style.top = tableTop + 'px';\n\n\t\t/* Cache some information for the scroller */\n\t\tthis.s.tableTop = tableTop;\n\t\tthis.s.tableBottom = iTableHeight + this.s.tableTop;\n\n\t\t// Calculate the boundaries for where a redraw will be triggered by the\n\t\t// scroll event listener\n\t\tvar boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;\n\t\tthis.s.redrawTop = iScrollTop - boundaryPx;\n\t\tthis.s.redrawBottom =\n\t\t\tiScrollTop + boundaryPx >\n\t\t\theights.scroll - heights.viewport - heights.row\n\t\t\t\t? heights.scroll - heights.viewport - heights.row\n\t\t\t\t: iScrollTop + boundaryPx;\n\n\t\tthis.s.skip = false;\n\n\t\tif (that.s.ingnoreScroll) {\n\t\t\t// Restore the scrolling position that was saved by DataTable's state\n\t\t\t// saving Note that this is done on the second draw when data is Ajax\n\t\t\t// sourced, and the first draw when DOM soured\n\t\t\tif (\n\t\t\t\tthis.s.dt.oFeatures.bStateSave &&\n\t\t\t\tthis.s.dt.oLoadedState !== null &&\n\t\t\t\ttypeof this.s.dt.oLoadedState.scroller != 'undefined'\n\t\t\t) {\n\t\t\t\t// A quirk of DataTables is that the draw callback will occur on an\n\t\t\t\t// empty set if Ajax sourced, but not if server-side processing.\n\t\t\t\tvar ajaxSourced =\n\t\t\t\t\t(this.s.dt.sAjaxSource || that.s.dt.ajax) &&\n\t\t\t\t\t!this.s.dt.oFeatures.bServerSide\n\t\t\t\t\t\t? true\n\t\t\t\t\t\t: false;\n\n\t\t\t\tif (\n\t\t\t\t\t(ajaxSourced && this.s.dt.iDraw >= 2) ||\n\t\t\t\t\t(!ajaxSourced && this.s.dt.iDraw >= 1)\n\t\t\t\t) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t$(that.dom.scroller).scrollTop(\n\t\t\t\t\t\t\tthat.s.dt.oLoadedState.scroller.scrollTop\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// In order to prevent layout thrashing we need another\n\t\t\t\t\t\t// small delay\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tthat.s.ingnoreScroll = false;\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthat.s.ingnoreScroll = false;\n\t\t\t}\n\t\t}\n\n\t\t// Because of the order of the DT callbacks, the info update will\n\t\t// take precedence over the one we want here. So a 'thread' break is\n\t\t// needed.  Only add the thread break if bInfo is set\n\t\tif (this.s.dt.oFeatures.bInfo) {\n\t\t\tsetTimeout(function () {\n\t\t\t\tthat._info.call(that);\n\t\t\t}, 0);\n\t\t}\n\n\t\t$(this.s.dt.nTable).triggerHandler('position.dts.dt', tableTop);\n\t},\n\n\t/**\n\t * Convert from one domain to another. The physical domain is the actual\n\t * pixel count on the screen, while the virtual is if we had browsers which\n\t * had scrolling containers of infinite height (i.e. the absolute value)\n\t *\n\t *  @param {string} dir Domain transform direction, `virtualToPhysical` or\n\t *    `physicalToVirtual`\n\t *  @returns {number} Calculated transform\n\t *  @private\n\t */\n\t_domain: function (dir, val) {\n\t\tvar heights = this.s.heights;\n\t\tvar diff;\n\t\tvar magic = 10000; // the point at which the non-linear calculations start to happen\n\n\t\t// If the virtual and physical height match, then we use a linear\n\t\t// transform between the two, allowing the scrollbar to be linear\n\t\tif (heights.virtual === heights.scroll) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// In the first 10k pixels and the last 10k pixels, we want the scrolling\n\t\t// to be linear. After that it can be non-linear. It would be unusual for\n\t\t// anyone to mouse wheel through that much.\n\t\tif (val < magic) {\n\t\t\treturn val;\n\t\t}\n\t\telse if (\n\t\t\tdir === 'virtualToPhysical' &&\n\t\t\tval >= heights.virtual - magic\n\t\t) {\n\t\t\tdiff = heights.virtual - val;\n\t\t\treturn heights.scroll - diff;\n\t\t}\n\t\telse if (dir === 'physicalToVirtual' && val >= heights.scroll - magic) {\n\t\t\tdiff = heights.scroll - val;\n\t\t\treturn heights.virtual - diff;\n\t\t}\n\n\t\t// Otherwise, we want a non-linear scrollbar to take account of the\n\t\t// redrawing regions at the start and end of the table, otherwise these\n\t\t// can stutter badly - on large tables 30px (for example) scroll might\n\t\t// be hundreds of rows, so the table would be redrawing every few px at\n\t\t// the start and end. Use a simple linear eq. to stop this, effectively\n\t\t// causing a kink in the scrolling ratio. It does mean the scrollbar is\n\t\t// non-linear, but with such massive data sets, the scrollbar is going\n\t\t// to be a best guess anyway\n\t\tvar m =\n\t\t\t(heights.virtual - magic - magic) /\n\t\t\t(heights.scroll - magic - magic);\n\t\tvar c = magic - m * magic;\n\n\t\treturn dir === 'virtualToPhysical' ? (val - c) / m : m * val + c;\n\t},\n\n\t/**\n\t * Update any information elements that are controlled by the DataTable based on the scrolling\n\t * viewport and what rows are visible in it. This function basically acts in the same way as\n\t * _fnUpdateInfo in DataTables, and effectively replaces that function.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_info: function () {\n\t\tif (!this.s.dt.oFeatures.bInfo) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar dt = this.s.dt,\n\t\t\tdtApi = this.s.dtApi,\n\t\t\tlanguage = dt.oLanguage,\n\t\t\tinfo = dtApi.page.info(),\n\t\t\ttotal = info.recordsDisplay,\n\t\t\tmax = info.recordsTotal;\n\n\t\t// If the scroll type is `cont` (continuous) we need to use `baseRowTop`, which\n\t\t// also means we need to work out the difference between the current scroll position\n\t\t// and the \"base\" for when it was required\n\t\tvar diffRows = (this.s.lastScrollTop - this.s.baseScrollTop) / this.s.heights.row;\n\t\tvar start = Math.floor(this.s.baseRowTop + diffRows) + 1;\n\n\t\t// For a jump scroll type, we just use the straightforward calculation based on\n\t\t// `topRowFloat`\n\t\tif (this.s.scrollType === 'jump') {\n\t\t\tstart = Math.floor(this.s.topRowFloat) + 1;\n\t\t}\n\n\t\tvar\n\t\t\tpossibleEnd = start + Math.floor(this.s.heights.viewport / this.s.heights.row),\n\t\t\tend = possibleEnd > total ? total : possibleEnd,\n\t\t\tresult;\n\n\t\tif (total === 0 && total == max) {\n\t\t\t/* Empty record set */\n\t\t\tresult = language.sInfoEmpty + language.sInfoPostFix;\n\t\t}\n\t\telse if (total === 0) {\n\t\t\t// Empty record set after filtering\n\t\t\tresult =\n\t\t\t\tlanguage.sInfoEmpty +\n\t\t\t\t' ' +\n\t\t\t\tlanguage.sInfoFiltered +\n\t\t\t\tlanguage.sInfoPostFix;\n\t\t}\n\t\telse if (total == max) {\n\t\t\t// Normal record set\n\t\t\tresult = language.sInfo + language.sInfoPostFix;\n\t\t}\n\t\telse {\n\t\t\t// Record set after filtering\n\t\t\tresult = language.sInfo + ' ' + language.sInfoFiltered + language.sInfoPostFix;\n\t\t}\n\n\t\tresult = this._macros(result, start, end, max, total);\n\n\t\tvar callback = language.fnInfoCallback;\n\t\tif (callback) {\n\t\t\tresult = callback.call(\n\t\t\t\tdt.oInstance,\n\t\t\t\tdt,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tmax,\n\t\t\t\ttotal,\n\t\t\t\tresult\n\t\t\t);\n\t\t}\n\n\t\t// DT 1.x features\n\t\tvar n = dt.aanFeatures.i;\n\t\tif (typeof n != 'undefined') {\n\t\t\tfor (var i = 0, iLen = n.length; i < iLen; i++) {\n\t\t\t\t$(n[i]).html(result);\n\t\t\t}\n\n\t\t\t$(dt.nTable).triggerHandler('info.dt');\n\t\t}\n\n\t\t// DT 2.x features\n\t\t$('div.dt-info', dtApi.table().container()).each(function () {\n\t\t\t$(this).html(result);\n\t\t\tdtApi.trigger('info', [dtApi.settings()[0], this, result]);\n\t\t});\n\t},\n\n\t/**\n\t * String replacement for info display. Basically the same as what DataTables does.\n\t *\n\t * @param {*} str\n\t * @param {*} start\n\t * @param {*} end\n\t * @param {*} max\n\t * @param {*} total\n\t * @returns Formatted string\n\t */\n\t_macros: function (str, start, end, max, total) {\n\t\tvar api = this.s.dtApi;\n\t\tvar settings = this.s.dt;\n\t\tvar formatter = settings.fnFormatNumber;\n\n\t\treturn str\n\t\t\t.replace(/_START_/g, formatter.call(settings, start))\n\t\t\t.replace(/_END_/g, formatter.call(settings, end))\n\t\t\t.replace(/_MAX_/g, formatter.call(settings, max))\n\t\t\t.replace(/_TOTAL_/g, formatter.call(settings, total))\n\t\t\t.replace(/_ENTRIES_/g, api.i18n('entries', ''))\n\t\t\t.replace(/_ENTRIES-MAX_/g, api.i18n('entries', '', max))\n\t\t\t.replace(/_ENTRIES-TOTAL_/g, api.i18n('entries', '', total));\n\t},\n\n\t/**\n\t * Parse CSS height property string as number\n\t *\n\t * An attempt is made to parse the string as a number. Currently supported units are 'px',\n\t * 'vh', and 'rem'. 'em' is partially supported; it works as long as the parent element's\n\t * font size matches the body element. Zero is returned for unrecognized strings.\n\t *  @param {string} cssHeight CSS height property string\n\t *  @returns {number} height\n\t *  @private\n\t */\n\t_parseHeight: function (cssHeight) {\n\t\tvar height;\n\t\tvar matches = /^([+-]?(?:\\d+(?:\\.\\d+)?|\\.\\d+))(px|em|rem|vh)$/.exec(\n\t\t\tcssHeight\n\t\t);\n\n\t\tif (matches === null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar value = parseFloat(matches[1]);\n\t\tvar unit = matches[2];\n\n\t\tif (unit === 'px') {\n\t\t\theight = value;\n\t\t}\n\t\telse if (unit === 'vh') {\n\t\t\theight = (value / 100) * $(window).height();\n\t\t}\n\t\telse if (unit === 'rem') {\n\t\t\theight = value * parseFloat($(':root').css('font-size'));\n\t\t}\n\t\telse if (unit === 'em') {\n\t\t\theight = value * parseFloat($('body').css('font-size'));\n\t\t}\n\n\t\treturn height ? height : 0;\n\t},\n\n\t/**\n\t * Scrolling function - fired whenever the scrolling position is changed.\n\t * This method needs to use the stored values to see if the table should be\n\t * redrawn as we are moving towards the end of the information that is\n\t * currently drawn or not. If needed, then it will redraw the table based on\n\t * the new position.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_scroll: function () {\n\t\tvar that = this,\n\t\t\theights = this.s.heights,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiTopRow;\n\n\t\tif (this.s.skip) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.s.ingnoreScroll) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (iScrollTop === this.s.lastScrollTop) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* If the table has been sorted or filtered, then we use the redraw that\n\t\t * DataTables as done, rather than performing our own\n\t\t */\n\t\tif (this.s.dt.bFiltered || this.s.dt.bSorted) {\n\t\t\tthis.s.lastScrollTop = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t/* We don't want to state save on every scroll event - that's heavy\n\t\t * handed, so use a timeout to update the state saving only when the\n\t\t * scrolling has finished\n\t\t */\n\t\tclearTimeout(this.s.stateTO);\n\t\tthis.s.stateTO = setTimeout(function () {\n\t\t\tthat.s.dtApi.state.save();\n\n\t\t\t// We can also use this to ensure that the `info` element is correct\n\t\t\t// since there can be a little scroll after the last scroll event!\n\t\t\tthat._info();\n\t\t}, 250);\n\n\t\tthis.s.scrollType =\n\t\t\tMath.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport\n\t\t\t\t? 'jump'\n\t\t\t\t: 'cont';\n\n\t\tthis.s.topRowFloat =\n\t\t\tthis.s.scrollType === 'cont'\n\t\t\t\t? this.pixelsToRow(iScrollTop, false, false)\n\t\t\t\t: this._domain('physicalToVirtual', iScrollTop) / heights.row;\n\n\t\tif (this.s.topRowFloat < 0) {\n\t\t\tthis.s.topRowFloat = 0;\n\t\t}\n\n\t\t/* Check if the scroll point is outside the trigger boundary which would required\n\t\t * a DataTables redraw\n\t\t */\n\t\tif (\n\t\t\tthis.s.forceReposition ||\n\t\t\tiScrollTop < this.s.redrawTop ||\n\t\t\tiScrollTop > this.s.redrawBottom\n\t\t) {\n\t\t\tvar preRows = Math.ceil(\n\t\t\t\t((this.s.displayBuffer - 1) / 2) * this.s.viewportRows\n\t\t\t);\n\n\t\t\tiTopRow = parseInt(this.s.topRowFloat, 10) - preRows;\n\t\t\tthis.s.forceReposition = false;\n\n\t\t\tif (iTopRow <= 0) {\n\t\t\t\t/* At the start of the table */\n\t\t\t\tiTopRow = 0;\n\t\t\t}\n\t\t\telse if (\n\t\t\t\tiTopRow + this.s.dt._iDisplayLength >\n\t\t\t\tthis.s.dt.fnRecordsDisplay()\n\t\t\t) {\n\t\t\t\t/* At the end of the table */\n\t\t\t\tiTopRow =\n\t\t\t\t\tthis.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;\n\t\t\t\tif (iTopRow < 0) {\n\t\t\t\t\tiTopRow = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (iTopRow % 2 !== 0) {\n\t\t\t\t// For the row-striping classes (odd/even) we want only to start\n\t\t\t\t// on evens otherwise the stripes will change between draws and\n\t\t\t\t// look rubbish\n\t\t\t\tiTopRow++;\n\t\t\t}\n\n\t\t\t// Store calcuated value, in case the following condition is not met, but so\n\t\t\t// that the draw function will still use it.\n\t\t\tthis.s.targetTop = iTopRow;\n\n\t\t\tif (iTopRow != this.s.dt._iDisplayStart) {\n\t\t\t\t/* Cache the new table position for quick lookups */\n\t\t\t\tthis.s.tableTop = $(this.s.dt.nTable).offset().top;\n\t\t\t\tthis.s.tableBottom =\n\t\t\t\t\t$(this.s.dt.nTable).height() + this.s.tableTop;\n\n\t\t\t\tvar draw = function () {\n\t\t\t\t\tthat.s.dt._iDisplayStart = that.s.targetTop;\n\t\t\t\t\tthat.s.dtApi.draw('page');\n\t\t\t\t};\n\n\t\t\t\t/* Do the DataTables redraw based on the calculated start point - note that when\n\t\t\t\t * using server-side processing we introduce a small delay to not DoS the server...\n\t\t\t\t */\n\t\t\t\tif (this.s.dt.oFeatures.bServerSide) {\n\t\t\t\t\tthis.s.forceReposition = true;\n\n\t\t\t\t\t// This is used only for KeyTable and is not currently publicly\n\t\t\t\t\t// documented. Open question - is it useful for anything else?\n\t\t\t\t\t$(this.s.dt.nTable).triggerHandler('scroller-will-draw.dt');\n\n\t\t\t\t\tif (DataTable.versionCheck('2')) {\n\t\t\t\t\t\tthat.s.dtApi.processing(true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.s.dt.oApi._fnProcessingDisplay(this.s.dt, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(this.s.drawTO);\n\t\t\t\t\tthis.s.drawTO = setTimeout(draw, this.s.serverWait);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.s.topRowFloat = this.pixelsToRow(iScrollTop, false, true);\n\t\t}\n\n\t\t/* Update the table's information display for what is now in the viewport */\n\t\tthis._info();\n\n\t\tthis.s.lastScrollTop = iScrollTop;\n\t\tthis.s.stateSaveThrottle();\n\n\t\tif (this.s.scrollType === 'jump' && this.s.mousedown) {\n\t\t\tthis.s.labelVisible = true;\n\t\t}\n\t\tif (this.s.labelVisible) {\n\t\t\tvar labelFactor =\n\t\t\t\t(heights.viewport - heights.labelHeight - heights.xbar) /\n\t\t\t\theights.scroll;\n\n\t\t\tthis.dom.label\n\t\t\t\t.html(\n\t\t\t\t\tthis.s.dt.fnFormatNumber(\n\t\t\t\t\t\tparseInt(this.s.topRowFloat, 10) + 1\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.css('top', iScrollTop + iScrollTop * labelFactor)\n\t\t\t\t.css('display', 'block');\n\t\t}\n\t},\n\n\t/**\n\t * Force the scrolling container to have height beyond that of just the\n\t * table that has been drawn so the user can scroll the whole data set.\n\t *\n\t * Note that if the calculated required scrolling height exceeds a maximum\n\t * value (1 million pixels - hard-coded) the forcing element will be set\n\t * only to that maximum value and virtual / physical domain transforms will\n\t * be used to allow Scroller to display tables of any number of records.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_scrollForce: function () {\n\t\tvar heights = this.s.heights;\n\t\tvar max = 1000000;\n\n\t\theights.virtual = heights.row * this.s.dt.fnRecordsDisplay();\n\t\theights.scroll = heights.virtual;\n\n\t\tif (heights.scroll > max) {\n\t\t\theights.scroll = max;\n\t\t}\n\n\t\t// Minimum height so there is always a row visible (the 'no rows found'\n\t\t// if reduced to zero filtering)\n\t\tthis.dom.force.style.height =\n\t\t\theights.scroll > this.s.heights.row\n\t\t\t\t? heights.scroll + 'px'\n\t\t\t\t: this.s.heights.row + 'px';\n\t}\n});\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Statics\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Scroller default settings for initialisation\n *  @namespace\n *  @name Scroller.defaults\n *  @static\n */\nScroller.defaults = {\n\t/**\n\t * Scroller uses the boundary scaling factor to decide when to redraw the table - which it\n\t * typically does before you reach the end of the currently loaded data set (in order to\n\t * allow the data to look continuous to a user scrolling through the data). If given as 0\n\t * then the table will be redrawn whenever the viewport is scrolled, while 1 would not\n\t * redraw the table until the currently loaded data has all been shown. You will want\n\t * something in the middle - the default factor of 0.5 is usually suitable.\n\t *  @type     float\n\t *  @default  0.5\n\t *  @static\n\t */\n\tboundaryScale: 0.5,\n\n\t/**\n\t * The display buffer is what Scroller uses to calculate how many rows it should pre-fetch\n\t * for scrolling. Scroller automatically adjusts DataTables' display length to pre-fetch\n\t * rows that will be shown in \"near scrolling\" (i.e. just beyond the current display area).\n\t * The value is based upon the number of rows that can be displayed in the viewport (i.e.\n\t * a value of 1), and will apply the display range to records before before and after the\n\t * current viewport - i.e. a factor of 3 will allow Scroller to pre-fetch 1 viewport's worth\n\t * of rows before the current viewport, the current viewport's rows and 1 viewport's worth\n\t * of rows after the current viewport. Adjusting this value can be useful for ensuring\n\t * smooth scrolling based on your data set.\n\t *  @type     int\n\t *  @default  9\n\t *  @static\n\t */\n\tdisplayBuffer: 9,\n\n\t/**\n\t * Scroller will attempt to automatically calculate the height of rows for it's internal\n\t * calculations. However the height that is used can be overridden using this parameter.\n\t *  @type     int|string\n\t *  @default  auto\n\t *  @static\n\t */\n\trowHeight: 'auto',\n\n\t/**\n\t * When using server-side processing, Scroller will wait a small amount of time to allow\n\t * the scrolling to finish before requesting more data from the server. This prevents\n\t * you from DoSing your own server! The wait time can be configured by this parameter.\n\t *  @type     int\n\t *  @default  200\n\t *  @static\n\t */\n\tserverWait: 200\n};\n\nScroller.oDefaults = Scroller.defaults;\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Constants\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Scroller version\n *  @type      String\n *  @default   See code\n *  @name      Scroller.version\n *  @static\n */\nScroller.version = '2.4.3';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on('preInit.dt.dtscroller', function (e, settings) {\n\tif (e.namespace !== 'dt') {\n\t\treturn;\n\t}\n\n\tvar init = settings.oInit.scroller;\n\tvar defaults = DataTable.defaults.scroller;\n\n\tif (init || defaults) {\n\t\tvar opts = $.extend({}, init, defaults);\n\n\t\tif (init !== false) {\n\t\t\tnew Scroller(settings, opts);\n\t\t}\n\t}\n});\n\n// Attach Scroller to DataTables so it can be accessed as an 'extra'\n$.fn.dataTable.Scroller = Scroller;\n$.fn.DataTable.Scroller = Scroller;\n\n// DataTables 1.10 API method aliases\nvar Api = $.fn.dataTable.Api;\n\nApi.register('scroller()', function () {\n\treturn this;\n});\n\n// Undocumented and deprecated - is it actually useful at all?\nApi.register('scroller().rowToPixels()', function (rowIdx, intParse, virtual) {\n\tvar ctx = this.context;\n\n\tif (ctx.length && ctx[0].oScroller) {\n\t\treturn ctx[0].oScroller.rowToPixels(rowIdx, intParse, virtual);\n\t}\n\t// undefined\n});\n\n// Undocumented and deprecated - is it actually useful at all?\nApi.register('scroller().pixelsToRow()', function (pixels, intParse, virtual) {\n\tvar ctx = this.context;\n\n\tif (ctx.length && ctx[0].oScroller) {\n\t\treturn ctx[0].oScroller.pixelsToRow(pixels, intParse, virtual);\n\t}\n\t// undefined\n});\n\n// `scroller().scrollToRow()` is undocumented and deprecated. Use `scroller.toPosition()\nApi.register(\n\t['scroller().scrollToRow()', 'scroller.toPosition()'],\n\tfunction (idx, ani) {\n\t\tthis.iterator('table', function (ctx) {\n\t\t\tif (ctx.oScroller) {\n\t\t\t\tctx.oScroller.scrollToRow(idx, ani);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n);\n\nApi.register('row().scrollTo()', function (ani) {\n\tvar that = this;\n\n\tthis.iterator('row', function (ctx, rowIdx) {\n\t\tif (ctx.oScroller) {\n\t\t\tvar displayIdx = that\n\t\t\t\t.rows({ order: 'applied', search: 'applied' })\n\t\t\t\t.indexes()\n\t\t\t\t.indexOf(rowIdx);\n\n\t\t\tctx.oScroller.scrollToRow(displayIdx, ani);\n\t\t}\n\t});\n\n\treturn this;\n});\n\nApi.register('scroller.measure()', function (redraw) {\n\tthis.iterator('table', function (ctx) {\n\t\tif (ctx.oScroller) {\n\t\t\tctx.oScroller.measure(redraw);\n\t\t}\n\t});\n\n\treturn this;\n});\n\nApi.register('scroller.page()', function () {\n\tvar ctx = this.context;\n\n\tif (ctx.length && ctx[0].oScroller) {\n\t\treturn ctx[0].oScroller.pageInfo();\n\t}\n\t// undefined\n});\n\n\nexport default DataTable;\n"],
  "mappings": ";;;;;;;;;;;;;;AAIA,IAAAA,iBAAmB;;;ACAnB,oBAAmB;AAInB,IAAI,IAAI,cAAAC;AAwDR,IAAI,WAAW,SAAU,IAAI,MAAM;AAElC,MAAI,EAAE,gBAAgB,WAAW;AAChC;AAAA,MACC;AAAA,IACD;AACA;AAAA,EACD;AAEA,MAAI,SAAS,QAAW;AACvB,WAAO,CAAC;AAAA,EACT;AAEA,MAAI,QAAQ,EAAE,GAAG,UAAU,IAAI,EAAE;AAQjC,OAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMR,IAAI,MAAM,SAAS,EAAE,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,IAMtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOV,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASb,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUX,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOd,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOZ,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASd,SAAS;AAAA,IAET,mBAAmB,WAAY;AAAA,IAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQhC,QAAQ;AAAA,IAER,SAAS;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOR,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOL,UAAU;AAAA,MACV,aAAa;AAAA,MACb,MAAM;AAAA,IACP;AAAA,IAEA,aAAa;AAAA,IACb,gBAAgB;AAAA,IAChB,eAAe;AAAA,IACf,iBAAiB;AAAA,IACjB,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,WAAW;AAAA,IACX,eAAe;AAAA,EAChB;AAIA,OAAK,IAAI,EAAE,OAAO,KAAK,GAAG,SAAS,WAAW,IAAI;AAGlD,OAAK,EAAE,QAAQ,MAAM,KAAK,EAAE;AAQ5B,OAAK,MAAM;AAAA,IACV,OAAO,SAAS,cAAc,KAAK;AAAA,IACnC,OAAO,EAAE,gCAAgC;AAAA,IACzC,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,EACT;AAIA,MAAI,KAAK,EAAE,GAAG,WAAW;AACxB;AAAA,EACD;AAEA,OAAK,EAAE,GAAG,YAAY;AAGtB,OAAK,UAAU;AAChB;AAEA,EAAE,OAAO,SAAS,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAc5B,SAAS,SAAU,QAAQ;AAC1B,QAAI,KAAK,EAAE,YAAY;AACtB,WAAK,eAAe;AAAA,IACrB;AAEA,QAAI,UAAU,KAAK,EAAE;AAErB,QAAI,QAAQ,KAAK;AAChB,cAAQ,WAAW,KAAK;AAAA,QACvB,EAAE,KAAK,IAAI,QAAQ,EAAE,IAAI,YAAY;AAAA,MACtC;AAEA,WAAK,EAAE,eACN,SAAS,QAAQ,WAAW,QAAQ,KAAK,EAAE,IAAI;AAChD,WAAK,EAAE,GAAG,kBACT,KAAK,EAAE,eAAe,KAAK,EAAE;AAAA,IAC/B;AAEA,QAAI,QAAQ,KAAK,IAAI,MAAM,YAAY;AAEvC,YAAQ,OACP,KAAK,IAAI,SAAS,eAAe,KAAK,IAAI,SAAS;AACpD,YAAQ,cAAc;AAEtB,QAAI,WAAW,UAAa,QAAQ;AACnC,WAAK,EAAE,MAAM,KAAK,KAAK;AAAA,IACxB;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,UAAU,WAAY;AACrB,QAAI,KAAK,KAAK,EAAE,IACf,aAAa,KAAK,IAAI,SAAS,WAC/B,SAAS,GAAG,iBAAiB,GAC7B,eAAe,KAAK;AAAA,MACnB,KAAK;AAAA,QACJ,aAAa,KAAK,EAAE,QAAQ;AAAA,QAC5B;AAAA,QACA,KAAK,EAAE;AAAA,MACR;AAAA,IACD;AAED,WAAO;AAAA,MACN,OAAO,KAAK,MAAM,KAAK,YAAY,YAAY,OAAO,KAAK,EAAE,GAAG,CAAC;AAAA,MACjE,KAAK,SAAS,eAAe,SAAS,IAAI,eAAe;AAAA,IAC1D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,aAAa,SAAU,QAAQ,UAAU,SAAS;AACjD,QAAI,OAAO,SAAS,KAAK,EAAE;AAC3B,QAAI,MAAM,WACN,KAAK,QAAQ,qBAAqB,KAAK,EAAE,aAAa,IAAI,QAC5D,KAAK,EAAE,QAAQ,MACd,OAAO,KAAK,EAAE,QAAQ,MAAM,KAAK,EAAE;AAEtC,WAAO,YAAY,aAAa,SAAY,SAAS,KAAK,EAAE,IAAI;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,SAAU,QAAQ,UAAU,SAAS;AACjD,QAAI;AACJ,QAAI,OAAO,SAAS,KAAK,EAAE;AAE3B,QAAI,SAAS;AACZ,eAAS,KAAK,QAAQ,qBAAqB,KAAK,EAAE,aAAa;AAC/D,gBAAU,OAAO,KAAK,EAAE,QAAQ;AAAA,IACjC,OACK;AACJ,eAAS,KAAK,EAAE;AAChB,gBAAU,OAAO,KAAK,EAAE,QAAQ;AAAA,IACjC;AAEA,WAAO,YAAY,aAAa,SAC7B,SAAS,QAAQ,EAAE,IACnB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,SAAU,KAAK,SAAS;AACpC,QAAI,OAAO;AACX,QAAI,MAAM;AACV,QAAI,KAAK,KAAK,YAAY,GAAG;AAO7B,QAAI,WAAY,KAAK,EAAE,gBAAgB,KAAK,IAAK,KAAK,EAAE;AACxD,QAAI,UAAU,MAAM;AACpB,QAAI,UAAU,GAAG;AAChB,gBAAU;AAAA,IACX;AAEA,SACE,KAAK,KAAK,EAAE,gBAAgB,KAAK,KAAK,EAAE,cACzC,KAAK,EAAE,GAAG,mBAAmB,SAC5B;AACD,YAAM;AACN,WAAK,KAAK,QAAQ,qBAAqB,MAAM,KAAK,EAAE,QAAQ,GAAG;AAK/D,UAAI,KAAK,EAAE,YAAY,MAAM,KAAK,KAAK,EAAE,cAAc;AACtD,aAAK,EAAE,kBAAkB;AACzB,kBAAU;AAAA,MACX;AAAA,IACD;AAEA,QAAI,YAAY,UAAa,SAAS;AACrC,WAAK,EAAE,MAAM;AACb,QAAE,KAAK,IAAI,QAAQ,EAAE;AAAA,QACpB;AAAA,UACC,WAAW;AAAA,QACZ;AAAA,QACA,WAAY;AAGX,qBAAW,WAAY;AACtB,iBAAK,EAAE,MAAM;AAAA,UACd,GAAG,GAAG;AAAA,QACP;AAAA,MACD;AAAA,IACD,OACK;AACJ,QAAE,KAAK,IAAI,QAAQ,EAAE,UAAU,EAAE;AAAA,IAClC;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,WAAW,WAAY;AACtB,QAAI,OAAO;AACX,QAAI,KAAK,KAAK,EAAE;AAGhB,QAAI,CAAC,KAAK,EAAE,GAAG,UAAU,WAAW;AACnC,YAAM,IAAI;AAAA,QACT;AAAA,MACD;AAAA,IACD;AAKA,SAAK,IAAI,MAAM,MAAM,WAAW;AAChC,SAAK,IAAI,MAAM,MAAM,MAAM;AAC3B,SAAK,IAAI,MAAM,MAAM,OAAO;AAC5B,SAAK,IAAI,MAAM,MAAM,QAAQ;AAE7B,SAAK,IAAI,WAAW,GAAG,MAAM,EAAE,KAAK,EAAE;AACtC,SAAK,IAAI,SAAS,YAAY,KAAK,IAAI,KAAK;AAC5C,SAAK,IAAI,SAAS,MAAM,WAAW;AAEnC,SAAK,IAAI,QAAQ,EAAE,UAAU,KAAK,IAAI,QAAQ,EAAE,CAAC;AACjD,SAAK,IAAI,MAAM,MAAM,WAAW;AAChC,SAAK,IAAI,MAAM,MAAM,MAAM;AAC3B,SAAK,IAAI,MAAM,MAAM,OAAO;AAG5B,MAAE,GAAG,MAAM,EAAE,UAAU,CAAC,EAAE,SAAS,SAAS;AAE5C,SAAK,IAAI,MAAM,SAAS,KAAK,IAAI,QAAQ;AAGzC,QAAI,KAAK,EAAE,QAAQ,OAAO,KAAK,EAAE,QAAQ,OAAO,QAAQ;AACvD,WAAK,EAAE,aAAa;AAAA,IACrB;AAGA,SAAK,EAAE,gBAAgB;AACvB,MAAE,KAAK,IAAI,QAAQ,EAAE,GAAG,sBAAsB,SAAU,GAAG;AAC1D,WAAK,QAAQ,KAAK,IAAI;AAAA,IACvB,CAAC;AAID,MAAE,KAAK,IAAI,QAAQ,EAAE,GAAG,0BAA0B,WAAY;AAC7D,WAAK,QAAQ,KAAK,IAAI;AAAA,IACvB,CAAC;AAED,MAAE,KAAK,IAAI,QAAQ,EACjB,GAAG,yBAAyB,WAAY;AACxC,WAAK,EAAE,YAAY;AAAA,IACpB,CAAC,EACA,GAAG,uBAAuB,WAAY;AACtC,WAAK,EAAE,eAAe;AACtB,WAAK,EAAE,YAAY;AACnB,WAAK,IAAI,MAAM,IAAI,WAAW,MAAM;AAAA,IACrC,CAAC;AAGF,MAAE,MAAM,EAAE,GAAG,sBAAsB,WAAY;AAC9C,WAAK,QAAQ,KAAK;AAClB,WAAK,MAAM;AAAA,IACZ,CAAC;AAID,QAAI,mBAAmB;AACvB,QAAI,cAAc,GAAG,MAAM,OAAO;AAElC,OAAG,GAAG,4BAA4B,SAAU,GAAG,UAAU,MAAM;AAC9D,UAAI,oBAAoB,aAAa;AACpC,aAAK,WAAW,YAAY;AAC5B,2BAAmB;AAEnB,YAAI,KAAK,UAAU;AAClB,eAAK,EAAE,gBAAgB,KAAK,SAAS;AAAA,QACtC;AAAA,MACD,OACK;AAEJ,aAAK,WAAW;AAAA,UACf,QAAQ,KAAK,EAAE;AAAA,UACf,YAAY,KAAK,EAAE;AAAA,QACpB;AAAA,MACD;AAAA,IACD,CAAC;AAED,OAAG,GAAG,4BAA4B,SAAU,GAAG,UAAU,MAAM;AAC9D,UAAI,KAAK,aAAa,QAAW;AAChC,aAAK,YAAY,KAAK,SAAS,MAAM;AAAA,MACtC;AAAA,IACD,CAAC;AAED,SAAK,QAAQ,KAAK;AAElB,QAAI,eAAe,YAAY,UAAU;AACxC,WAAK,EAAE,cAAc,YAAY,SAAS;AAC1C,WAAK,EAAE,aAAa,YAAY,SAAS;AAKzC,WAAK,EAAE,gBAAgB,KAAK,EAAE,aAAa,KAAK,EAAE,QAAQ;AAC1D,kBAAY,SAAS,YAAY,KAAK,QAAQ,qBAAqB,KAAK,EAAE,cAAc,KAAK,EAAE,QAAQ,GAAG;AAAA,IAC3G;AAEA,SAAK,EAAE,oBAAoB,mBAAU,KAAK,SAAS,WAAY;AAC9D,WAAK,EAAE,MAAM,MAAM,KAAK;AAAA,IACzB,GAAG,GAAG;AAEN,OAAG,GAAG,iBAAiB,WAAY;AAClC,WAAK,QAAQ,KAAK;AAIlB,WAAK,EAAE,aAAa;AACpB,WAAK,MAAM;AAGX,SAAG,GAAG,iBAAiB,WAAY;AAClC,aAAK,MAAM;AAAA,MACZ,CAAC;AAAA,IACF,CAAC;AAID,OAAG,GAAG,uBAAuB,WAAY;AACxC,WAAK,aAAa;AAAA,IACnB,CAAC;AAGD,OAAG,GAAG,oBAAoB,WAAY;AACrC,QAAE,MAAM,EAAE,IAAI,oBAAoB;AAClC,QAAE,KAAK,IAAI,QAAQ,EAAE,IAAI,cAAc;AACvC,QAAE,KAAK,EAAE,GAAG,MAAM,EAAE,IAAI,WAAW;AAEnC,QAAE,KAAK,EAAE,GAAG,aAAa,EAAE,YAAY,KAAK;AAC5C,QAAE,mBAAmB,KAAK,IAAI,SAAS,UAAU,EAAE,OAAO;AAE1D,WAAK,IAAI,MAAM,MAAM,WAAW;AAChC,WAAK,IAAI,MAAM,MAAM,MAAM;AAC3B,WAAK,IAAI,MAAM,MAAM,OAAO;AAAA,IAC7B,CAAC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,gBAAgB,WAAY;AAC3B,QAAI,KAAK,KAAK,EAAE;AAChB,QAAI,YAAY,GAAG;AACnB,QAAI,SAAS,UAAU,UAAU,KAAK;AACtC,QAAI,QAAQ,EAAE,UAAU,EAAE,SAAS,MAAM;AACzC,QAAI,YAAY,GAAG;AAGnB,QAAI,UAAU,mBAAU,aAAa,GAAG,IACrC;AAAA,MACA,WAAW,UAAU;AAAA,MACrB,UAAU,UAAU,UAAU;AAAA,MAC9B,MAAM,UAAU,UAAU;AAAA,IAC5B,IACE;AAAA,MACA,WAAW,UAAU;AAAA,MACrB,UAAU,UAAU;AAAA,MACpB,MAAM,UAAU;AAAA,IAClB;AAED,QAAI,YAAY;AAAA,MACf,iBACC,QAAQ,YACR,uBACA,QAAQ,WACR,mBACA,QAAQ,OACR;AAAA,IACF;AAIA,MAAE,kBAAkB,SAAS,EAAE,MAAM,EAAE,SAAS,KAAK;AACrD,QAAI,YAAY,EAAE,MAAM,KAAK,EAAE;AAE/B,QAAI,cAAc,GAAG;AACpB,YAAM,QAAQ,0BAA0B;AACxC,YAAM,OAAO,0BAA0B;AAAA,IACxC,OACK;AACJ,aAAO,YAAY,GAAG,aAAa;AAClC,cAAM,OAAO,0BAA0B;AAAA,MACxC;AAAA,IACD;AAEA,MAAE,SAAS,QAAQ,MAAM,SAAS,EAAE,OAAO,MAAM;AAGjD,QAAI,WAAW,KAAK,EAAE,GAAG,YAAY,UAAU;AAE/C,QAAI,CAAC,EAAE,QAAQ,EAAE,GAAG,UAAU,GAAG;AAChC,iBAAW;AAAA,IACZ;AAGA,cAAU,KAAK,OAAO,EAAE,WAAW,MAAM;AAEzC,cAAU,SAAS,QAAQ;AAC3B,SAAK,EAAE,QAAQ,MAAM,EAAE,MAAM,KAAK,EAAE,GAAG,CAAC,EAAE,YAAY;AAEtD,cAAU,OAAO;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,WAAY;AAClB,QAAI,OAAO,MACV,UAAU,KAAK,EAAE,SACjB,aAAa,KAAK,IAAI,SAAS,WAC/B,eAAe,EAAE,KAAK,EAAE,GAAG,MAAM,EAAE,OAAO,GAC1C,eAAe,KAAK,EAAE,GAAG,gBACzB,aAAa,KAAK,EAAE,GAAG,iBACvB,aAAa,KAAK,EAAE,GAAG,iBAAiB,GACxC,eAAe,aAAa,QAAQ;AAGrC,SAAK,EAAE,OAAO;AAGd,SACE,KAAK,EAAE,GAAG,WAAW,KAAK,EAAE,GAAG,cAChC,iBAAiB,KACjB,CAAC,KAAK,EAAE,GAAG,WACV;AACD,WAAK,EAAE,cAAc;AAAA,IACtB;AAEA,iBACC,KAAK,EAAE,eAAe,SACnB,KAAK;AAAA,MACN;AAAA,MACA,KAAK,EAAE,cAAc,QAAQ;AAAA,IAC9B,IACE;AAIJ,SAAK,EAAE,gBAAgB;AACvB,SAAK,EAAE,aAAa,KAAK,EAAE;AAG3B,QAAI,WACH,cAAc,KAAK,EAAE,cAAc,gBAAgB,QAAQ;AAC5D,QAAI,iBAAiB,GAAG;AACvB,iBAAW;AAAA,IACZ,WACS,eAAe,cAAc,YAAY;AACjD,iBAAW,QAAQ,SAAS;AAAA,IAC7B,OACK;AACJ,UAAI,gBAAgB,WAAW;AAC/B,UAAI,gBAAgB,cAAc;AAGjC,YAAI,cAAc,eAAe;AACjC,YAAI,SAAS,cAAc;AAC3B,aAAK,EAAE,iBAAiB,SAAS;AACjC,mBAAW;AAAA,MACZ;AAAA,IACD;AAEA,SAAK,IAAI,MAAM,MAAM,MAAM,WAAW;AAGtC,SAAK,EAAE,WAAW;AAClB,SAAK,EAAE,cAAc,eAAe,KAAK,EAAE;AAI3C,QAAI,cAAc,aAAa,KAAK,EAAE,YAAY,KAAK,EAAE;AACzD,SAAK,EAAE,YAAY,aAAa;AAChC,SAAK,EAAE,eACN,aAAa,aACb,QAAQ,SAAS,QAAQ,WAAW,QAAQ,MACzC,QAAQ,SAAS,QAAQ,WAAW,QAAQ,MAC5C,aAAa;AAEjB,SAAK,EAAE,OAAO;AAEd,QAAI,KAAK,EAAE,eAAe;AAIzB,UACC,KAAK,EAAE,GAAG,UAAU,cACpB,KAAK,EAAE,GAAG,iBAAiB,QAC3B,OAAO,KAAK,EAAE,GAAG,aAAa,YAAY,aACzC;AAGD,YAAI,eACF,KAAK,EAAE,GAAG,eAAe,KAAK,EAAE,GAAG,SACpC,CAAC,KAAK,EAAE,GAAG,UAAU,cAClB,OACA;AAEJ,YACE,eAAe,KAAK,EAAE,GAAG,SAAS,KAClC,CAAC,eAAe,KAAK,EAAE,GAAG,SAAS,GACnC;AACD,qBAAW,WAAY;AACtB,cAAE,KAAK,IAAI,QAAQ,EAAE;AAAA,cACpB,KAAK,EAAE,GAAG,aAAa,SAAS;AAAA,YACjC;AAIA,uBAAW,WAAY;AACtB,mBAAK,EAAE,gBAAgB;AAAA,YACxB,GAAG,CAAC;AAAA,UACL,GAAG,CAAC;AAAA,QACL;AAAA,MACD,OACK;AACJ,aAAK,EAAE,gBAAgB;AAAA,MACxB;AAAA,IACD;AAKA,QAAI,KAAK,EAAE,GAAG,UAAU,OAAO;AAC9B,iBAAW,WAAY;AACtB,aAAK,MAAM,KAAK,IAAI;AAAA,MACrB,GAAG,CAAC;AAAA,IACL;AAEA,MAAE,KAAK,EAAE,GAAG,MAAM,EAAE,eAAe,mBAAmB,QAAQ;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,SAAS,SAAU,KAAK,KAAK;AAC5B,QAAI,UAAU,KAAK,EAAE;AACrB,QAAI;AACJ,QAAI,QAAQ;AAIZ,QAAI,QAAQ,YAAY,QAAQ,QAAQ;AACvC,aAAO;AAAA,IACR;AAKA,QAAI,MAAM,OAAO;AAChB,aAAO;AAAA,IACR,WAEC,QAAQ,uBACR,OAAO,QAAQ,UAAU,OACxB;AACD,aAAO,QAAQ,UAAU;AACzB,aAAO,QAAQ,SAAS;AAAA,IACzB,WACS,QAAQ,uBAAuB,OAAO,QAAQ,SAAS,OAAO;AACtE,aAAO,QAAQ,SAAS;AACxB,aAAO,QAAQ,UAAU;AAAA,IAC1B;AAUA,QAAI,KACF,QAAQ,UAAU,QAAQ,UAC1B,QAAQ,SAAS,QAAQ;AAC3B,QAAI,IAAI,QAAQ,IAAI;AAEpB,WAAO,QAAQ,uBAAuB,MAAM,KAAK,IAAI,IAAI,MAAM;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,WAAY;AAClB,QAAI,CAAC,KAAK,EAAE,GAAG,UAAU,OAAO;AAC/B;AAAA,IACD;AAEA,QAAI,KAAK,KAAK,EAAE,IACf,QAAQ,KAAK,EAAE,OACf,WAAW,GAAG,WACd,OAAO,MAAM,KAAK,KAAK,GACvB,QAAQ,KAAK,gBACb,MAAM,KAAK;AAKZ,QAAI,YAAY,KAAK,EAAE,gBAAgB,KAAK,EAAE,iBAAiB,KAAK,EAAE,QAAQ;AAC9E,QAAI,QAAQ,KAAK,MAAM,KAAK,EAAE,aAAa,QAAQ,IAAI;AAIvD,QAAI,KAAK,EAAE,eAAe,QAAQ;AACjC,cAAQ,KAAK,MAAM,KAAK,EAAE,WAAW,IAAI;AAAA,IAC1C;AAEA,QACC,cAAc,QAAQ,KAAK,MAAM,KAAK,EAAE,QAAQ,WAAW,KAAK,EAAE,QAAQ,GAAG,GAC7E,MAAM,cAAc,QAAQ,QAAQ,aACpC;AAED,QAAI,UAAU,KAAK,SAAS,KAAK;AAEhC,eAAS,SAAS,aAAa,SAAS;AAAA,IACzC,WACS,UAAU,GAAG;AAErB,eACC,SAAS,aACT,MACA,SAAS,gBACT,SAAS;AAAA,IACX,WACS,SAAS,KAAK;AAEtB,eAAS,SAAS,QAAQ,SAAS;AAAA,IACpC,OACK;AAEJ,eAAS,SAAS,QAAQ,MAAM,SAAS,gBAAgB,SAAS;AAAA,IACnE;AAEA,aAAS,KAAK,QAAQ,QAAQ,OAAO,KAAK,KAAK,KAAK;AAEpD,QAAI,WAAW,SAAS;AACxB,QAAI,UAAU;AACb,eAAS,SAAS;AAAA,QACjB,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAGA,QAAI,IAAI,GAAG,YAAY;AACvB,QAAI,OAAO,KAAK,aAAa;AAC5B,eAAS,IAAI,GAAG,OAAO,EAAE,QAAQ,IAAI,MAAM,KAAK;AAC/C,UAAE,EAAE,CAAC,CAAC,EAAE,KAAK,MAAM;AAAA,MACpB;AAEA,QAAE,GAAG,MAAM,EAAE,eAAe,SAAS;AAAA,IACtC;AAGA,MAAE,eAAe,MAAM,MAAM,EAAE,UAAU,CAAC,EAAE,KAAK,WAAY;AAC5D,QAAE,IAAI,EAAE,KAAK,MAAM;AACnB,YAAM,QAAQ,QAAQ,CAAC,MAAM,SAAS,EAAE,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,IAC1D,CAAC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,SAAS,SAAU,KAAK,OAAO,KAAK,KAAK,OAAO;AAC/C,QAAI,MAAM,KAAK,EAAE;AACjB,QAAI,WAAW,KAAK,EAAE;AACtB,QAAI,YAAY,SAAS;AAEzB,WAAO,IACL,QAAQ,YAAY,UAAU,KAAK,UAAU,KAAK,CAAC,EACnD,QAAQ,UAAU,UAAU,KAAK,UAAU,GAAG,CAAC,EAC/C,QAAQ,UAAU,UAAU,KAAK,UAAU,GAAG,CAAC,EAC/C,QAAQ,YAAY,UAAU,KAAK,UAAU,KAAK,CAAC,EACnD,QAAQ,cAAc,IAAI,KAAK,WAAW,EAAE,CAAC,EAC7C,QAAQ,kBAAkB,IAAI,KAAK,WAAW,IAAI,GAAG,CAAC,EACtD,QAAQ,oBAAoB,IAAI,KAAK,WAAW,IAAI,KAAK,CAAC;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,cAAc,SAAU,WAAW;AAClC,QAAI;AACJ,QAAI,UAAU,iDAAiD;AAAA,MAC9D;AAAA,IACD;AAEA,QAAI,YAAY,MAAM;AACrB,aAAO;AAAA,IACR;AAEA,QAAI,QAAQ,WAAW,QAAQ,CAAC,CAAC;AACjC,QAAI,OAAO,QAAQ,CAAC;AAEpB,QAAI,SAAS,MAAM;AAClB,eAAS;AAAA,IACV,WACS,SAAS,MAAM;AACvB,eAAU,QAAQ,MAAO,EAAE,MAAM,EAAE,OAAO;AAAA,IAC3C,WACS,SAAS,OAAO;AACxB,eAAS,QAAQ,WAAW,EAAE,OAAO,EAAE,IAAI,WAAW,CAAC;AAAA,IACxD,WACS,SAAS,MAAM;AACvB,eAAS,QAAQ,WAAW,EAAE,MAAM,EAAE,IAAI,WAAW,CAAC;AAAA,IACvD;AAEA,WAAO,SAAS,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SAAS,WAAY;AACpB,QAAI,OAAO,MACV,UAAU,KAAK,EAAE,SACjB,aAAa,KAAK,IAAI,SAAS,WAC/B;AAED,QAAI,KAAK,EAAE,MAAM;AAChB;AAAA,IACD;AAEA,QAAI,KAAK,EAAE,eAAe;AACzB;AAAA,IACD;AAEA,QAAI,eAAe,KAAK,EAAE,eAAe;AACxC;AAAA,IACD;AAKA,QAAI,KAAK,EAAE,GAAG,aAAa,KAAK,EAAE,GAAG,SAAS;AAC7C,WAAK,EAAE,gBAAgB;AACvB;AAAA,IACD;AAMA,iBAAa,KAAK,EAAE,OAAO;AAC3B,SAAK,EAAE,UAAU,WAAW,WAAY;AACvC,WAAK,EAAE,MAAM,MAAM,KAAK;AAIxB,WAAK,MAAM;AAAA,IACZ,GAAG,GAAG;AAEN,SAAK,EAAE,aACN,KAAK,IAAI,aAAa,KAAK,EAAE,aAAa,IAAI,QAAQ,WACnD,SACA;AAEJ,SAAK,EAAE,cACN,KAAK,EAAE,eAAe,SACnB,KAAK,YAAY,YAAY,OAAO,KAAK,IACzC,KAAK,QAAQ,qBAAqB,UAAU,IAAI,QAAQ;AAE5D,QAAI,KAAK,EAAE,cAAc,GAAG;AAC3B,WAAK,EAAE,cAAc;AAAA,IACtB;AAKA,QACC,KAAK,EAAE,mBACP,aAAa,KAAK,EAAE,aACpB,aAAa,KAAK,EAAE,cACnB;AACD,UAAI,UAAU,KAAK;AAAA,SAChB,KAAK,EAAE,gBAAgB,KAAK,IAAK,KAAK,EAAE;AAAA,MAC3C;AAEA,gBAAU,SAAS,KAAK,EAAE,aAAa,EAAE,IAAI;AAC7C,WAAK,EAAE,kBAAkB;AAEzB,UAAI,WAAW,GAAG;AAEjB,kBAAU;AAAA,MACX,WAEC,UAAU,KAAK,EAAE,GAAG,kBACpB,KAAK,EAAE,GAAG,iBAAiB,GAC1B;AAED,kBACC,KAAK,EAAE,GAAG,iBAAiB,IAAI,KAAK,EAAE,GAAG;AAC1C,YAAI,UAAU,GAAG;AAChB,oBAAU;AAAA,QACX;AAAA,MACD,WACS,UAAU,MAAM,GAAG;AAI3B;AAAA,MACD;AAIA,WAAK,EAAE,YAAY;AAEnB,UAAI,WAAW,KAAK,EAAE,GAAG,gBAAgB;AAExC,aAAK,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,MAAM,EAAE,OAAO,EAAE;AAC/C,aAAK,EAAE,cACN,EAAE,KAAK,EAAE,GAAG,MAAM,EAAE,OAAO,IAAI,KAAK,EAAE;AAEvC,YAAI,OAAO,WAAY;AACtB,eAAK,EAAE,GAAG,iBAAiB,KAAK,EAAE;AAClC,eAAK,EAAE,MAAM,KAAK,MAAM;AAAA,QACzB;AAKA,YAAI,KAAK,EAAE,GAAG,UAAU,aAAa;AACpC,eAAK,EAAE,kBAAkB;AAIzB,YAAE,KAAK,EAAE,GAAG,MAAM,EAAE,eAAe,uBAAuB;AAE1D,cAAI,mBAAU,aAAa,GAAG,GAAG;AAChC,iBAAK,EAAE,MAAM,WAAW,IAAI;AAAA,UAC7B,OACK;AACJ,iBAAK,EAAE,GAAG,KAAK,qBAAqB,KAAK,EAAE,IAAI,IAAI;AAAA,UACpD;AAEA,uBAAa,KAAK,EAAE,MAAM;AAC1B,eAAK,EAAE,SAAS,WAAW,MAAM,KAAK,EAAE,UAAU;AAAA,QACnD,OACK;AACJ,eAAK;AAAA,QACN;AAAA,MACD;AAAA,IACD,OACK;AACJ,WAAK,EAAE,cAAc,KAAK,YAAY,YAAY,OAAO,IAAI;AAAA,IAC9D;AAGA,SAAK,MAAM;AAEX,SAAK,EAAE,gBAAgB;AACvB,SAAK,EAAE,kBAAkB;AAEzB,QAAI,KAAK,EAAE,eAAe,UAAU,KAAK,EAAE,WAAW;AACrD,WAAK,EAAE,eAAe;AAAA,IACvB;AACA,QAAI,KAAK,EAAE,cAAc;AACxB,UAAI,eACF,QAAQ,WAAW,QAAQ,cAAc,QAAQ,QAClD,QAAQ;AAET,WAAK,IAAI,MACP;AAAA,QACA,KAAK,EAAE,GAAG;AAAA,UACT,SAAS,KAAK,EAAE,aAAa,EAAE,IAAI;AAAA,QACpC;AAAA,MACD,EACC,IAAI,OAAO,aAAa,aAAa,WAAW,EAChD,IAAI,WAAW,OAAO;AAAA,IACzB;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,cAAc,WAAY;AACzB,QAAI,UAAU,KAAK,EAAE;AACrB,QAAI,MAAM;AAEV,YAAQ,UAAU,QAAQ,MAAM,KAAK,EAAE,GAAG,iBAAiB;AAC3D,YAAQ,SAAS,QAAQ;AAEzB,QAAI,QAAQ,SAAS,KAAK;AACzB,cAAQ,SAAS;AAAA,IAClB;AAIA,SAAK,IAAI,MAAM,MAAM,SACpB,QAAQ,SAAS,KAAK,EAAE,QAAQ,MAC7B,QAAQ,SAAS,OACjB,KAAK,EAAE,QAAQ,MAAM;AAAA,EAC1B;AACD,CAAC;AAYD,SAAS,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYnB,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBf,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASf,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUX,YAAY;AACb;AAEA,SAAS,YAAY,SAAS;AAa9B,SAAS,UAAU;AAQnB,EAAE,QAAQ,EAAE,GAAG,yBAAyB,SAAU,GAAG,UAAU;AAC9D,MAAI,EAAE,cAAc,MAAM;AACzB;AAAA,EACD;AAEA,MAAI,OAAO,SAAS,MAAM;AAC1B,MAAI,WAAW,mBAAU,SAAS;AAElC,MAAI,QAAQ,UAAU;AACrB,QAAI,OAAO,EAAE,OAAO,CAAC,GAAG,MAAM,QAAQ;AAEtC,QAAI,SAAS,OAAO;AACnB,UAAI,SAAS,UAAU,IAAI;AAAA,IAC5B;AAAA,EACD;AACD,CAAC;AAGD,EAAE,GAAG,UAAU,WAAW;AAC1B,EAAE,GAAG,UAAU,WAAW;AAG1B,IAAI,MAAM,EAAE,GAAG,UAAU;AAEzB,IAAI,SAAS,cAAc,WAAY;AACtC,SAAO;AACR,CAAC;AAGD,IAAI,SAAS,4BAA4B,SAAU,QAAQ,UAAU,SAAS;AAC7E,MAAI,MAAM,KAAK;AAEf,MAAI,IAAI,UAAU,IAAI,CAAC,EAAE,WAAW;AACnC,WAAO,IAAI,CAAC,EAAE,UAAU,YAAY,QAAQ,UAAU,OAAO;AAAA,EAC9D;AAED,CAAC;AAGD,IAAI,SAAS,4BAA4B,SAAU,QAAQ,UAAU,SAAS;AAC7E,MAAI,MAAM,KAAK;AAEf,MAAI,IAAI,UAAU,IAAI,CAAC,EAAE,WAAW;AACnC,WAAO,IAAI,CAAC,EAAE,UAAU,YAAY,QAAQ,UAAU,OAAO;AAAA,EAC9D;AAED,CAAC;AAGD,IAAI;AAAA,EACH,CAAC,4BAA4B,uBAAuB;AAAA,EACpD,SAAU,KAAK,KAAK;AACnB,SAAK,SAAS,SAAS,SAAU,KAAK;AACrC,UAAI,IAAI,WAAW;AAClB,YAAI,UAAU,YAAY,KAAK,GAAG;AAAA,MACnC;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AACD;AAEA,IAAI,SAAS,oBAAoB,SAAU,KAAK;AAC/C,MAAI,OAAO;AAEX,OAAK,SAAS,OAAO,SAAU,KAAK,QAAQ;AAC3C,QAAI,IAAI,WAAW;AAClB,UAAI,aAAa,KACf,KAAK,EAAE,OAAO,WAAW,QAAQ,UAAU,CAAC,EAC5C,QAAQ,EACR,QAAQ,MAAM;AAEhB,UAAI,UAAU,YAAY,YAAY,GAAG;AAAA,IAC1C;AAAA,EACD,CAAC;AAED,SAAO;AACR,CAAC;AAED,IAAI,SAAS,sBAAsB,SAAU,QAAQ;AACpD,OAAK,SAAS,SAAS,SAAU,KAAK;AACrC,QAAI,IAAI,WAAW;AAClB,UAAI,UAAU,QAAQ,MAAM;AAAA,IAC7B;AAAA,EACD,CAAC;AAED,SAAO;AACR,CAAC;AAED,IAAI,SAAS,mBAAmB,WAAY;AAC3C,MAAI,MAAM,KAAK;AAEf,MAAI,IAAI,UAAU,IAAI,CAAC,EAAE,WAAW;AACnC,WAAO,IAAI,CAAC,EAAE,UAAU,SAAS;AAAA,EAClC;AAED,CAAC;;;AD7zCD,IAAO,8BAAQ;",
  "names": ["import_jquery", "jQuery"]
}
